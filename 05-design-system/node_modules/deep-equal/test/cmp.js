'use strict';

var test = require('tape');
require('./_tape');
var assign = require('object.assign');
var gOPDs = require('object.getownpropertydescriptors');
var hasSymbols = require('has-symbols')();
var hasTypedArrays = require('has-typed-arrays')();
var semver = require('semver');

var safeBuffer = typeof Buffer === 'function' ? Buffer.from && Buffer.from.length > 1 ? Buffer.from : Buffer : null;
var buffersAreTypedArrays = typeof Buffer === 'function' && new Buffer(0) instanceof Uint8Array;

var isNode = typeof process === 'object' && typeof process.version === 'string';

function tag(obj, value) {
  if (hasSymbols && Symbol.toStringTag && Object.defineProperty) {
    Object.defineProperty(obj, Symbol.toStringTag, {
      value: value
    });
  }
  return obj;
}

// eslint-disable-next-line no-proto
var hasDunderProto = [].__proto__ === Array.prototype;

test('equal', function (t) {
  t.deepEqualTest(
    { a: [2, 3], b: [4] },
    { a: [2, 3], b: [4] },
    'two equal objects',
    true,
    true,
    false
  );

  t.deepEqualTest(
    { a: 2, b: '4' },
    { a: 2, b: 4 },
    'two loosely equal, strictly inequal objects',
    true,
    false
  );

  t.deepEqualTest(
    { a: 2, b: 4 },
    { a: 2, B: 4 },
    'two inequal objects',
    false,
    false
  );

  t.deepEqualTest(
    '-000',
    false,
    '`false` and `"-000"`',
    true,
    false
  );

  t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
  t.deepEqualTest(
    new Map([['a', 1], ['b', 2]]),
    new Map([['b', 2], ['a', 1]]),
    'two equal Maps',
    true,
    true
  );

  t.deepEqualTest(
    new Map([['a', [1, 2]]]),
    new Map([['a', [2, 1]]]),
    'two Maps with inequal values on the same key',
    false,
    false
  );

  t.deepEqualTest(
    new Map([['a', 1]]),
    new Map([['b', 1]]),
    'two inequal Maps',
    false,
    false
  );

  t.deepEqualTest(
    new Map([[{}, 3], [{}, 2], [{}, 1]]),
    new Map([[{}, 1], [{}, 2], [{}, 3]]),
    'two equal Maps in different orders with object keys',
    true,
    true
  );

  t.deepEqualTest(
    new Map([[undefined, undefined]]),
    new Map([[undefined, null]]),
    'undefined keys, nullish values, loosely equal, strictly inequal',
    true,
    false
  );

  t.deepEqualTest(
    new Map([[{}, null], [true, 2], [{}, 1], [undefined, {}]]),
    new Map([[{}, 1], [true, 2], [{}, null], [undefined, {}]]),
    'two equal Maps in different orders with primitive keys',
    true,
    true
  );

  t.deepEqualTest(
    new Map([[false, 3], [{}, 2], [{}, 1]]),
    new Map([[{}, 1], [{}, 2], [false, 3]]),
    'two equal Maps in different orders with a mix of keys',
    true,
    true
  );

  t.deepEqualTest(
    new Map([[null, undefined]]),
    new Map([[null, null]]),
    'null keys, nullish values, loosely equal, strictly inequal',
    true,
    false
  );

  t.deepEqualTest(
    new Map([[undefined, 3]]),
    new Map([[null, 3]]),
    'nullish keys, loosely equal, strictly inequal',
    true,
    false
  );

  t.deepEqualTest(
    new Map([[{}, null], [true, 2], [{}, 1], [undefined, {}]]),
    new Map([[{}, 1], [true, 2], [{}, null], [undefined, {}]]),
    'two equal Maps in different orders with primitive keys',
    true,
    true
  );

  t.deepEqualTest(
    new Map([[false, 3], [{}, 2], [{}, 1]]),
    new Map([[{}, 1], [{}, 2], [false, 3]]),
    'two equal Maps in different orders with a mix of keys',
    true,
    true
  );

  t.deepEqualTest(
    new Map(),
    new Map([[{}, 1]]),
    'two inequal Maps',
    false,
    false
  );

  t.deepEqualTest(
    new Map([[{}, null], [false, 3]]),
    new Map([[{}, null], [true, 2]]),
    'two inequal maps, same size, primitive key, start with object key',
    false,
    false
  );

  t.deepEqualTest(
    new Map([[false, 3], [{}, null]]),
    new Map([[true, 2], [{}, null]]),
    'two inequal maps, same size, primitive key, start with primitive key',
    false,
    false
  );

  t.deepEqualTest(
    new Map([[undefined, null], ['+000', 2]]),
    new Map([[null, undefined], [false, '2']]),
    'primitive comparisons',
    true,
    false
  );

  t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
  t.deepEqualTest(
    new WeakMap([[Object, null], [Function, true]]),
    new WeakMap([[Function, true], [Object, null]]),
    'two equal WeakMaps',
    true,
    true
  );

  t.deepEqualTest(
    new WeakMap([[Object, null]]),
    new WeakMap([[Object, true]]),
    'two WeakMaps with inequal values on the same key',
    true,
    true
  );

  t.deepEqualTest(
    new WeakMap([[Object, null], [Function, true]]),
    new WeakMap([[Object, null]]),
    'two inequal WeakMaps',
    true,
    true
  );

  t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
  t.deepEqualTest(
    new Set(['a', 1, 'b', 2]),
    new Set(['b', 2, 'a', 1]),
    'two equal Sets',
    true,
    true
  );

  t.deepEqualTest(
    new Set(['a', 1]),
    new Set(['b', 1]),
    'two inequal Sets',
    false,
    false
  );

  t.deepEqualTest(
    new Set([{}, 1, {}, {}, 2]),
    new Set([{}, 1, {}, 2, {}]),
    'two equal Sets in different orders',
    true,
    true
  );

  t.deepEqualTest(
    new Set(),
    new Set([1]),
    'two inequally sized Sets',
    false,
    false
  );

  t.deepEqualTest(
    new Set([{ a: 1 }, 2]),
    new Set(['2', { a: '1' }]),
    'two loosely equal, strictly inequal Sets',
    true,
    false
  );

  t.deepEqualTest(
    new Set([{ a: 1 }, 2]),
    new Set(['2', { a: 2 }]),
    'two inequal Sets',
    false,
    false
  );

  t.deepEqualTest(
    new Set([null, '', 1, 5, 2, false]),
    new Set([undefined, 0, '5', true, '2', '-000']),
    'more primitive comparisons',
    true,
    false
  );

  t.end();
});

test('Set and Map', { skip: !Object.defineProperty || typeof Set !== 'function' || typeof Map !== 'function' }, function (t) {
  t.deepEqualTest(
    new Set(),
    new Map(),
    'Map and Set',
    false,
    false
  );

  var maplikeSet = new Set();
  Object.defineProperty(maplikeSet, 'constructor', { enumerable: false, value: Map });
  maplikeSet.__proto__ = Map.prototype; // eslint-disable-line no-proto
  t.deepEqualTest(
    maplikeSet,
    new Map(),
    'Map-like Set, and Map',
    false,
    false
  );

  t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
  t.deepEqualTest(
    new WeakSet([Object, Function]),
    new WeakSet([Function, Object]),
    'two equal WeakSets',
    true,
    true
  );

  t.deepEqualTest(
    new WeakSet([Object, Function]),
    new WeakSet([Object]),
    'two inequal WeakSets',
    true,
    true
  );

  t.end();
});

test('not equal', function (t) {
  t.deepEqualTest(
    { x: 5, y: [6] },
    { x: 5, y: 6 },
    'two inequal objects are',
    false,
    false
  );

  t.end();
});

test('nested nulls', function (t) {
  t.deepEqualTest(
    [null, null, null],
    [null, null, null],
    'same-length arrays of nulls',
    true,
    true,
    true
  );
  t.end();
});

test('objects with strings vs numbers', function (t) {
  t.deepEqualTest(
    [{ a: 3 }, { b: 4 }],
    [{ a: '3' }, { b: '4' }],
    'objects with equivalent string/number values',
    true,
    false
  );
  t.end();
});

test('non-objects', function (t) {
  t.deepEqualTest(3, 3, 'same numbers', true, true, true);
  t.deepEqualTest('beep', 'beep', 'same strings', true, true, true);
  t.deepEqualTest('3', 3, 'numeric string and number', true, false);
  t.deepEqualTest('3', [3], 'numeric string and array containing number', false, false);
  t.deepEqualTest(3, [3], 'number and array containing number', false, false);

  t.end();
});

test('infinities', function (t) {
  t.deepEqualTest(Infinity, Infinity, '∞ and ∞', true, true, true);
  t.deepEqualTest(-Infinity, -Infinity, '-∞ and -∞', true, true, true);
  t.deepEqualTest(Infinity, -Infinity, '∞ and -∞', false, false);

  t.end();
});

test('arguments class', function (t) {
  function getArgs() {
    return arguments;
  }

  t.deepEqualTest(
    getArgs(1, 2, 3),
    getArgs(1, 2, 3),
    'equivalent arguments objects are equal',
    true,
    true,
    true
  );

  t.deepEqualTest(
    get